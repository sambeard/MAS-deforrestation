extensions [ cf ]
breed [ foresters forester ]
breed [ farmers farmer]

globals [
  patch-list
  government-money
  community-money
  last-tick-breed
  last-tick-zero
  dead-agents
  breeded-agents
  last-comm-money
  gr-comm-money
  last-gr-comm-money
]

turtles-own [ target targetType task task-list inventory]; forester parameters
farmers-own [ seeds ]; farmers parameters


to setup-agents
  initialize-foresters initial-amount-of-foresters
  initialize-farmers initial-amount-of-farmers
  setup-free-patches
  set government-money 1000
  set community-money 1000
  set last-tick-breed ticks
  set last-tick-zero ticks
  set dead-agents 0
end

to update-agents
  ask turtles [
    (cf:ifelse
      task = "" [get-new-task]
      target = nobody [set-new-target]
      ; if target patch has changed 
      [ptype] of target != get-patch-type-for-task task [set-new-target]
      ;; if forester on his target
      distance target = 0 [perform-task release-target target]
      [move-towards-target]
      )
  ]
    update-community-money
end


to update-community-money
  set community-money community-money - (count turtles) * living-cost 
  set gr-comm-money (1 - plot-alpha) * gr-comm-money + plot-alpha * (community-money - last-comm-money)
  
  (cf:ifelse 
    (community-money) <= 0 and (gr-comm-money < 0) and (ticks - last-tick-zero >= ticks-th) [
      ask one-of turtles [die] 
      set dead-agents dead-agents + 1
      set last-tick-zero ticks
    ]
    (community-money) <= 0 and (gr-comm-money < 0) and (ticks - last-tick-zero < ticks-th)[]
    (community-money >= 0) or (gr-comm-money > 0) [set last-tick-zero ticks] ;; reset if any of metrics is above threshold
  )
  (cf:ifelse 
    ( (community-money) >= breeding-money-th)  and (gr-comm-money > gr-thresh) and  (ticks - last-tick-breed >= ticks-th) [
      let probability random-float 1
    
      (cf:ifelse 
        (probability >= 0.5) and (count turtles < max-agents)  [add-forester]
        (probability < 0.5) and (count turtles < max-agents) [add-farmer]
      )
      set breeded-agents breeded-agents + 1
      set community-money community-money - breeding-cost
      set last-tick-breed ticks
    ]
    (community-money) >= breeding-money-th and (gr-comm-money > gr-thresh) and (ticks - last-tick-breed < ticks-th)[]
    (community-money >= breeding-money-th) or (community-money < breeding-money-th) or (gr-comm-money < gr-thresh) [set last-tick-breed ticks]
   )
  
  set last-comm-money community-money
  set last-gr-comm-money gr-comm-money
end
;; AGENT RELATED
;; ===================


to add-forester
  initialize-foresters 1
end

to add-farmer
  initialize-farmers 1
end

to initialize-foresters [amount]
  create-foresters amount [
    setup-agent
    set color 54 ;; yellow
  ]
  ;;show count turtles
end

to initialize-farmers [amount]
  create-farmers amount [
    setup-agent
    set color 45 ;; yellow
    set seeds max-seeds
  ]
end

to setup-agent
  set shape "person"
  set size 3
  set target a-city-patch
  set task "go home"
  set task-list []
  let current a-city-patch
  setxy ([pxcor] of current) ([pycor] of current)
  face target 
end

to remove-forester
  ask one-of foresters [die]
end

to remove-farmer
  ask one-of farmers [die]
end

to-report has-inventory?
  report inventory != ""
end

;; TASK RELATED
;; ==================
to-report get-patch-type-for-task [t]
  report (ifelse-value
    t = "chop forest" ["old forest"]
    t = "replant forest" ["wasteland"]
    t = "plant seeds" ["wasteland"]
    t = "harvest crops" ["crops"]
    t = "ignite forest" ["young forest"]
    t = "get seeds" ["city"]
    t = "deliver crops" ["city"]
    t = "deliver logs" ["city"]
    t = "go home" ["city"]
    [ nobody] ; break on this
  )
end 

to chop-forest
  set ptype "young forest"
  set inventory "logs"
  after-change-patch
end

to planting-crops
  set ptype "farmland"
  after-change-patch
  set seeds seeds - 1
  if(seeds = 0) [set color red]
end

to get-seeds
  set seeds max-seeds
  set color 45; yellow
  set task ""
end

to ask-to-ignite
  if (random 100 < ask-to-light-chance)
  [
    ; choose best spot
    let best-patch min-one-of (patches with [ptype = "young forest" and (item patch-index patch-list) != nobody and (distance myself <= max-travel-distance)] ) [distance myself]
    if( is-patch? best-patch)
    [
      ; find closest forester
      let closest-forester min-one-of foresters with [distance best-patch <= max-travel-distance and (target = nobody or distance target > 0) and task != "ignite forest"] [distance best-patch]
      ; ask to ignite
      if(is-forester? closest-forester)
      [
        ask closest-forester [
          ; set current work aside
          let ctask task
          let ctarget target
          set task-list fput (list ctask ctarget) task-list
          release-target ctarget
          ; set new task
          set task "ignite forest"
          set target best-patch
          claim-target target
          show word "will set fire to: " best-patch
        ]
      ]
    ]
  ]  
end

to replant-forest
  set ptype "young forest"
  after-change-patch
end

to harvest-crops
  let rand random 100
  
  ifelse rand > probability-to-turn-into-wasteland and seeds > 0
    [set ptype "farmland"]
    [set ptype "wasteland"]

  set inventory "crops"
  after-change-patch
end

to deliver-inventory
  (cf:ifelse 
    inventory = "logs" [
      set community-money community-money + (logs-selling-value * (1 - taxes-logs))
      set government-money government-money + (logs-selling-value * (taxes-logs))
    ] ;;LOGS give 2 money points
    inventory  = "crops" [set community-money community-money + (crops-selling-value * (1 - taxes-crops))
      set government-money government-money + (crops-selling-value * (taxes-crops))] ;; Crops give 1 money point
    inventory = "" []
  )
  set inventory ""
end

to move-towards-target
  if(target != nobody)[
    face target
    ifelse distance target <= movement-speed
      [ move-to target ]
      [ fd movement-speed ]
  ]
end


to perform-task
  (cf:ifelse
    task = "chop forest" [chop-forest]
    task = "plant seeds" [planting-crops]
    task = "harvest crops" [harvest-crops]
    task = "replant forest" [replant-forest]
    task = "get seeds" [get-seeds]
    task = "ignite forest" [ignite]
    task = "deliver crops" [deliver-inventory];; also implement 'selling' of crops
    task = "deliver logs" [deliver-inventory];; also implement 'selling' of logs
    task = "go home" [if is-farmer? self [ask-to-ignite]]
    []
  )
  set task ""
end

to get-new-task 
  if empty? task-list
  [
    let wasteland closest-available-patch "wasteland"
    ifelse is-farmer? self [
      let field closest-available-patch "crops"
      let young-forest closest-available-patch "young forest"
      set task-list lput (ifelse-value 
        has-inventory? [(list "deliver crops" nobody)]
        field != nobody [(list "harvest crops" field)]
        seeds = 0 [(list "get seeds" nobody)]  
        wasteland != nobody [(list "plant seeds" field)]  
        [(list "go home" nobody)]   
      ) task-list
    ]
    ; is forester
    [
      let old-forest closest-available-patch "old forest"
      set task-list lput (ifelse-value 
        inventory = "logs" [(list "deliver logs" nobody)]
        old-forest != nobody [(list "chop forest" old-forest)]
        wasteland != nobody and (random 100 < reforest-chance) [(list "replant forest" wasteland)]
        [(list "go home" nobody)]   
      ) task-list
    ]
  ]
  get-next-task
  ifelse (target = nobody)
    [set-new-target]
    [claim-target target]
end

to get-next-task
  let next first task-list
  set task item 0 next
  set target item 1 next
  set task-list butfirst task-list
end

to set-new-target
  if(target != nobody) [release-target target]
  let tt get-patch-type-for-task task
  set target ifelse-value (task = "go home")
  [ a-city-patch ]
  [ closest-patch unattended-patches with [ptype = tt and ifelse-value (tt = "city")[true][distance myself <= max-travel-distance ]]]
  ifelse (target = nobody) 
    ; clear task if no patches left to harvest
    [if(task = "harvest crops") [set task ""]]
    [claim-target target]
end

to release-target [t]
  if(is-patch? t)
  [set patch-list replace-item [patch-index] of t patch-list t]
end

to claim-target [t]
  if(is-patch? t)
  [set patch-list replace-item [patch-index] of t patch-list nobody]
end


;; PATCH RELATED
;; ===================
to-report get-ptype 
  report [ptype] of patch-here
end

to-report unattended-patches
  ; patch-set automatically filters out all non patch entries (eg nobodies)
  report patch-set filter is-patch? patch-list 
end
  
to-report closest-available-patch [patch-type]
  report closest-patch patches with [ptype = patch-type and (item patch-index patch-list) != nobody and distance myself <= max-travel-distance]
end

to-report closest-patch [patchset]
  ifelse (any? patchset )[
    let ph patch-here
    report first sort-on [distance ph] patchset
  ]
  [report nobody]
end

to-report a-city-patch
  report one-of patches with [ptype = "city"]
end

to setup-free-patches
  set patch-list (reduce [[l p] -> ifelse-value (p = 0) [(list)] [lput p l] ] (list (sort-on [patch-index] patches)))
end

to-report patch-index
  report world-width * pycor + pxcor
end


